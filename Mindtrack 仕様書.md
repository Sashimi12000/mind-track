# **Mindtrack 仕様書**

**バージョン履歴**

* V5: 正式名称決定版  
* V6: UI/UXの具体化、ビジネスロジック詳細化、バリデーションルール、OS依存機能、セキュリティ、テスト目標を追記し、完全な仕様書として統合。

## **1\. はじめに**

本仕様書は、アプリケーション「Mindtrack」の設計と開発に関する詳細を定義するものです。将来的なデータ同期機能の拡張を見据えたデータ管理設計に加え、具体的な実装方針とバージョニング及び自動更新の仕組みを盛り込んでいます。

## **2\. 目的**

本ツール「Mindtrack」は、ユーザーが日々の心身の状態を客観的に把握し、「超スモールステップ」（心理的抵抗を最小限にする極めて小さな行動単位）でのタスク実行を習慣化することで、無理なく自己規律を段階的に構築することを支援します。ワーキングメモリへの負荷を徹底的に軽減し、ユーザーが「できた！」という小さな成功体験を日々積み重ねられるよう設計することで、自己効力感を育み、持続的な行動変容を促します。  
本ツールはWindows, macOS, iOSデバイスで利用可能とし、ユーザーが日常的に利用する環境で、自己内省と行動計画・実行を一貫してサポートすることを目指します。

## **3\. ターゲットユーザー**

* 自己規律を身につけたいが、何から始めれば良いか分からず、具体的な行動に移せないユーザー。  
* 過去の失敗体験から行動への一歩が踏み出せない、または将来への漠然とした不安を抱え、現状を少しでも好転させたいと願うユーザー。  
* 複雑な操作や多機能なツールに苦手意識があり、ワーキングメモリの負荷を避けたい、シンプルで直感的な操作性を求めるユーザー。  
* 「小さく始めて、継続すること」の重要性を理解し、そのための具体的なサポートツールを求めているユーザー。

## **4\. 主要機能**

* **デイリーチェックイン機能**: 毎日の心身の状態、気分、そして「やるべきこと」に対する感情を記録し、自己認識を深める。  
* **マイクロタスクプランナー機能**: 「超スモールステップ」の具体的な行動タスクを設定し、実行をサポートする。  
* **達成ログ＆承認フィードバック機能**: 小さな行動の完了を記録・可視化し、ポジティブなフィードバックを通じて自己肯定感を高める。  
* **ふりかえり機能**: 過去の記録（気分、体調、タスク達成状況）を振り返り、自身のパターンや進捗を客観的に確認する。  
* **リマインダー機能**: デイリーチェックインやタスク実行を適切なタイミングで通知し、習慣化をサポートする。

## **5\. 技術スタック**

* デスクトップ/モバイルアプリケーションフレームワーク: Tauri 2.0 (対応プラットフォーム: Windows, macOS, iOS)  
* フロントエンド: SvelteKit (HTML, TypeScript), Tailwind CSS, daisyUI  
* バックエンド: Rust  
* データベース: SQLite (ローカル)

## **6\. 詳細機能仕様**

### **6.1. デイリーチェックイン機能**

* **目的**: ユーザーが毎日の心身の状態を記録する習慣を身につけ、自己理解を深め、無理のない行動計画の土台を作る。  
* **UI/UX**:  
  * アプリ起動時や設定時刻にモーダル形式で表示。daisyUIを活用し、視覚的に分かりやすい入力UIを提供する。  
  * **画面レイアウト**: モーダル上部に「今日のチェックイン」というタイトル。その下に各入力項目を縦に配置。最下部に「記録する」ボタンを設置。  
  * 入力完了後は「今日も一日、あなたらしく。」といったポジティブなフィードバックメッセージをtoastで短時間表示する。  
* **入力項目**:  
  * 日付（自動入力、表示のみ）  
  * 今の気分（5段階の絵文字アイコンから選択。例: 😭, 😥,😐, 🙂, 😄）  
  * 気分の補足（任意入力のテキストエリア）  
  * 体の状態（タグ形式で複数選択。例: 「寝不足」「元気」「頭痛」「肩こり」。自由記述も可）  
  * 今日の「やらなきゃ」と感じること（最大3つまで入力可能なテキストフィールド）  
  * それに対する今の気持ち（選択式。例: 「憂鬱」「まあまあ」「やれそう」）  
* データ構造 (SQLiteテーブル daily\_checkins):  
  | カラム名 | 型 | 制約 | 説明 |  
  |:---|:---|:---|:---|  
  | local\_id | INTEGER | PRIMARY KEY AUTOINCREMENT | ローカルID |  
  | uuid | TEXT | NOT NULL, UNIQUE | グローバル一意ID |  
  | date | TEXT | NOT NULL, UNIQUE, YYYY-MM-DD形式 | 記録日 |  
  | mood\_level | INTEGER | NOT NULL, 1-5の整数 | 気分レベル |  
  | mood\_text | TEXT | NULL許容, max 500 chars | 気分の補足 |  
  | physical\_state\_tags | TEXT | NULL許容 | 体の状態（タグをJSON配列文字列で保存） |  
  | physical\_state\_text | TEXT | NULL許容, max 500 chars | 体の状態（自由記述） |  
  | potential\_todos | TEXT | NULL許容 | 「やらなきゃ」をJSON配列文字列で保存 |  
  | created\_at | TEXT | NOT NULL | 作成日時 (ISO 8601\) |  
  | updated\_at | TEXT | NOT NULL | 更新日時 (ISO 8601\) |  
  | deleted\_at | TEXT | NULL許容 | 論理削除日時 (ISO 8601\) |

### **6.2. マイクロタスクプランナー機能**

* **目的**: 「やらなきゃ」を心理的抵抗の少ない「超スモールステップ」に分解・設定し、行動開始のハードルを極限まで下げる。  
* **UI/UX**:  
  * メイン画面に「今日のマイクロタスク」リストを表示。  
  * リスト下部の「＋タスクを追加」ボタンで入力フィールドを表示。プレースホルダーで「例: 5分だけ部屋を片付ける」のように具体例を提示。  
  * 各タスクには左側に完了チェックボックス、右側に編集・削除ボタンを配置。  
* **機能**: タスクの追加、完了、編集、削除が可能。完了チェックで達成ログ機能と連携する。  
* データ構造 (SQLiteテーブル micro\_tasks):  
  | カラム名 | 型 | 制約 | 説明 |  
  |:---|:---|:---|:---|  
  | local\_id | INTEGER | PRIMARY KEY AUTOINCREMENT | ローカルID |  
  | uuid | TEXT | NOT NULL, UNIQUE | グローバル一意ID |  
  | daily\_checkin\_uuid | TEXT | NOT NULL | 紐づくデイリーチェックインのUUID |  
  | task\_description | TEXT | NOT NULL, max 200 chars, Not Empty | タスク内容 |  
  | task\_memo | TEXT | NULL許容, max 1000 chars | タスクのメモ |  
  | is\_completed | INTEGER | NOT NULL DEFAULT 0 | 完了フラグ (0:未完了, 1:完了) |  
  | completed\_at | TEXT | NULL許容 | 完了日時 (ISO 8601\) |  
  | created\_at | TEXT | NOT NULL | 作成日時 (ISO 8601\) |  
  | updated\_at | TEXT | NOT NULL | 更新日時 (ISO 8601\) |  
  | deleted\_at | TEXT | NULL許容 | 論理削除日時 (ISO 8601\) |  
  | sort\_order | INTEGER | NOT NULL | 表示順序 |

### **6.3. 達成ログ＆承認フィードバック機能**

* **目的**: マイクロタスクの完了という「小さな成功体験」を即座にユーザーにフィードバックし、自己肯定感を高める。  
* **UI/UX**:  
  * マイクロタスク完了時、画面中央にdaisyUIのtoastやアニメーション付きのalertを2〜3秒間表示する。  
  * **アニメーション**: フェードイン後、少し拡大してからフェードアウトするような、控えめながらもポジティブな動き。オプションで紙吹雪が舞うような簡易なエフェクトも検討。  
  * **効果音**: 「キラキラ」「ポロン」といった、短く心地よいサウンド。  
  * **設定**: アニメーションと効果音は、それぞれ個別にON/OFF設定を可能とする。  
* **機能**:  
  * マイクロタスクが「完了」とマークされた際に自動的に発動。  
  * **メッセージ生成ロジック**: 以下のテンプレートからランダムに選択し、 {task\_description} 部分に完了したタスクの内容を挿入する。  
    * 「{task\_description}」を達成！素晴らしい一歩です！  
    * ナイス！「{task\_description}」を完了しましたね！  
    * よくできました！「{task\_description}」をクリア！  
    * タスク名が長い場合（例: 30文字以上）は、「タスクを一つ達成！その調子！」のような汎用メッセージに切り替える。  
* **データフロー**: フロントエンドがバックエンドへ完了を通知。バックエンドがmicro\_tasksテーブルのis\_completedとcompleted\_atを更新。フロントエンドが承認メッセージを表示する。

### **6.4. ふりかえり機能**

* **目的**: 自身の行動パターン、気分の波、進捗を客観的に把握し、今後の行動改善や自己理解に繋げる。  
* **UI/UX**:  
  * **カレンダービュー**: 月表示カレンダー。各日付にその日の気分アイコンと、タスク達成率（例: 3/5）を小さく表示。日付クリックでその日の詳細記録（チェックイン内容とタスク一覧）をモーダル表示。  
  * **リストビュー**: 「過去7日間」「過去30日間」「月選択」で期間を指定。指定期間の記録を日付ごとにカード形式で一覧表示する。  
  * **簡易統計表示**: リストビューの上部に表示。  
* **機能**:  
  * 日付選択による日ごとの記録詳細表示。  
  * 期間指定による記録のフィルタリングと一覧表示。  
  * **統計データ算出ロジック**:  
    * **気分レベルの分布**: (指定期間内の各気分レベルの日数 / 指定期間の総日数) \* 100 で割合を算出。棒グラフ等で可視化。  
    * **マイクロタスク平均完了率**: (指定期間内に完了したタスク総数 / 指定期間内に作成されたタスク総数) \* 100 で算出。

### **6.5. リマインダー機能**

* **目的**: 行動の習慣化をサポートし、「やらなきゃ」と意識し続けることによるワーキングメモリの負荷を軽減する。  
* **UI/UX**:  
  * 設定画面でリマインダーのオン/オフと時刻を設定可能にする。  
  * OS標準の通知機能を利用する。メッセージは「今日のチェックインしませんか？」「まだタスクが残っていますよ」など、簡潔で圧迫感を与えない内容とする。  
* **機能**:  
  * **デイリーチェックイン**: ユーザーが設定した時刻に、その日のチェックインが未実施の場合に通知を送信。  
  * **未完了タスク**: （オプション機能として設定画面でON/OFF可能）ユーザーが設定した時刻に、その日のタスクリストにis\_completed \= 0のタスクが1つ以上存在する場合に通知を送信。通知は1日1回のみ。  
* **OS間挙動**:  
  * 通知の表示形式は各OS（Windows, macOS, iOS）の標準スタイルに従う。メッセージ内容と通知をタップした際の挙動の共通化を目指す。  
  * **ディープリンク**: 通知をタップした場合、アプリが起動し、関連画面に直接遷移させる。URLスキーム mindtrack:// を使用し、 mindtrack://checkin や mindtrack://tasks のようなパスで画面遷移を制御する。

## **7\. アーキテクチャ概要**

* **SvelteKit (フロントエンド)**: ユーザーインターフェース (UI) の構築、ユーザーからの入力処理、表示ロジックを担当する。  
* **Rust (バックエンド)**: ビジネスロジックの実行、SQLiteデータベースとの永続化処理、システムレベルの操作（OS通知など）を担当する。  
* **Tauri**: SvelteKitで構築されたWeb UIをネイティブのデスクトップ・モバイルアプリケーションとしてパッケージングする。フロントエンドとバックエンド間の安全かつ効率的なIPCを提供し、OSネイティブ機能へのアクセスを可能にする。

## **8\. 開発における考慮事項**

### **8.1. ユーザーオンボーディング**

初回起動時に、以下のステップで構成されるオンボーディングプロセスを実装する。

1. **Welcome画面**: アプリのロゴと簡単な歓迎メッセージ。  
2. **コンセプト説明**: 「超スモールステップ」の重要性をイラスト付きで簡潔に説明。「大きな目標も、小さな一歩から。」  
3. **機能紹介**: デイリーチェックインとマイクロタスクの入力方法をインタラクティブなチュートリアルで案内。  
4. **リマインダー設定**: 通知の許可を求め、リマインダー時刻の設定を促す。スキップも可能。

### **8.2. その他の考慮事項**

* **段階的リリースとフィードバック収集**: MVPを早期にリリースし、フィードバックを収集しながら改善を重ねる。  
* **モジュール性とコンポーネントベース設計**: 保守性、再利用性、テスト容易性を高める。  
* **エラーハンドリングとフィードバック**: 堅牢なエラーハンドリングを実装し、ユーザーにはエラー内容を分かりやすく伝える。  
* **パフォーマンス**: 軽量で応答性の高いアプリケーションを目指す。  
* **UI/UXのシンプルさと直感性**: ユーザーが迷わず操作できることを最重要項目とする。  
* **データ永続化と安全性**: ローカルDBは安全に保存し、将来のクラウド同期を見据えたデータ設計を採用する。  
* **クロスプラットフォーム対応**: Tauri 2.0を最大限活用し、各プラットフォームで十分なUI/UXテストを実施する。  
* **アクセシビリティ (a11y)**: WCAG 2.1のAAレベル準拠を目標とし、キーボードナビゲーションやスクリーンリーダー対応を確保する。

### **8.3. セキュリティ**

* **IPC通信の検証**: Tauriのcapabilities機能を活用し、tauri.conf.jsonでフロントエンドから呼び出し可能なRust関数を明示的に許可する。原則として、必要なコマンドのみを公開し、least-privilege（最小権限）の原則に従う。  
* **データベースの保護**: 将来的な拡張として、SQLiteデータベースファイル自体の暗号化を検討する。tauri-plugin-sqlの機能や関連クレートを活用。  
* **外部URLへの遷移**: アプリ内から外部リンクを開く際は、必ずOSのデフォルトブラウザで開くようにし、アプリ内ブラウザでの表示は行わない。

### **8.4. テスト戦略**

* バックエンド（単体/結合テスト）、フロントエンド（コンポーネントテスト）、E2Eテストを組み合わせ、品質を担保する。  
* **テストカバレッジ目標**: バックエンドのRustロジック（単体/結合テスト）および、主要なフロントエンドコンポーネントにおいて、**80%以上**のテストカバレッジを目標とする。

## **9\. 今後の拡張性（オプション）**

* **【最優先検討】クラウド同期機能（オプション）**: ユーザーが任意で有効にできるオプトイン機能として提供。複数デバイス間でのシームレスなデータ利用とバックアップを実現する。BaaS (Firebaseなど) の活用を検討。  
* **データのエクスポート/インポート**: 機種変更時やユーザー自身によるバックアップのための機能。（初期リリース後の早い段階で搭載を検討）  
* **テーマカスタマイズ**: ライト/ダークモード含む複数のカラーテーマを提供。  
* **習慣トラッカー**: 特定の行動の実行状況を可視化する機能。  
* **進捗の視覚的フィードバック強化（ライトなゲーミフィケーション）**: プレッシャーにならない補助的な要素を取り入れ、モチベーション維持を支援。  
* **パスコード/生体認証ロック**: プライベートな記録を保護するオプション。  
* **Apple Watch連携 (iOS版)**: クイック操作を可能にする。  
* **リマインダー機能の強化**: 複数時刻設定、スヌーズ機能など。  
* **承認フィードバックのパーソナライズ**: ユーザーが好むスタイルを選択できる機能。  
* **コミュニティ機能**: （優先度低）プレッシャーにならない設計を最優先。  
* **専門家（カウンセラー等）との連携**: （スコープ外）

## **10\. 用語集**

* **超スモールステップ**: 心理的抵抗を最小限にするために、タスクを極めて小さな行動単位に分解したもの。ユーザーが「これならできそう」と即座に感じられるレベルを目指す。  
* **デイリーチェックイン**: 毎日の心身の状態や気分、その日に意識している「やらなきゃ」と感じることを記録する行為。  
* **マイクロタスク**: 「超スモールステップ」に基づいて設定された具体的な行動タスク。  
* **(その他、開発を進める中で定義が必要になった用語を追記)**

## **11\. 実装方針 (Implementation Strategy)**

この章では、本仕様書で定義された機能をどのように実現するかの具体的な技術的アプローチと設計方針を定めます。

### **11.1. バックエンド (Rust) 方針**

* **API設計 (Tauri Commands)**:  
  * フロントエンドからの呼び出しは、すべてTauriの\#\[tauri::command\]アトリビュートを付けた非同期関数として定義します。  
* **エラーハンドリング**:  
  * アプリケーション固有の明確なエラー型として `AppError` を `thiserror` クレートを用いて定義します。これにより、エラーの種類に応じた具体的な処理や、フロントエンドへの情報提供が可能になります。
  * `AppError` の各バリアントは、基本的に以下の情報を保持します。
    * `user_message: String`: ユーザーインターフェースに表示するための、簡潔で分かりやすいメッセージ。
    * `details: String` または `message: String`: 開発者向けのログやデバッグに使用する、より技術的で詳細な情報。
    * `source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>` または具体的なエラー型 (例: `std::io::Error`): エラーチェイニングを可能にし、根本原因を特定しやすくするための情報。
    * その他、エラーの種類に応じて必要な追加情報（例: `Validation` エラーにおける `field: String`、`NotFound` エラーにおける `resource_type: String`, `resource_id: String` など）。
  * アプリケーション内部の関数で、複数の異なるエラー型を扱う場合や、定型的なエラー伝播を簡潔に記述したい場合には `anyhow` クレートを利用します。`anyhow::Result<T>` や `anyhow::Error` を活用し、`?` 演算子による早期リターンを容易にします。
  * フロントエンドにエラー情報を渡す際は、`AppError` を直接シリアライズするのではなく、必要な情報のみを含む `SerializableAppError`のような中間構造体を介して行います。これにより、ユーザーに不要な詳細情報が渡ることを防ぎます。`AppError` はこの中間構造体に変換するために `serde::Serialize` を手動で実装します。シリアライズされる情報には、エラーのカテゴリを示す `UserMessageKind`、ユーザー向けの `message`、そしてエラーの種類に応じた追加のコンテキスト（例: `field`、`resource_type`）が含まれます。
  * 全てのTauriコマンドは`Result<T, AppError>`を返すことを規約とします。内部で `anyhow::Error` を使用した場合でも、コマンドの境界で `AppError` に変換します。これには、`AppError` に `From<anyhow::Error>` を実装するか、または `anyhow::Error` の情報を基に適切な `AppError` バリアントを生成する処理を記述します。例えば、`anyhow::Error` をラップする `AppError::InternalError { user_message: String, details: String }` のようなバリアントを定義し、`anyhow::Error` の内容を `details` として格納し、汎用的な `user_message` を設定する方法が考えられます。
  * `AppError` の実装例 (現在の `error.rs` の構造を反映):
    ```rust
    use serde::Serialize; // Serialize は AppError 自体の実装ではなく、SerializableAppError で使用
    use thiserror::Error;

    // ユーザーに提示するエラーメッセージの分類
    #[derive(Debug, Serialize, Clone, PartialEq)] // Serialize は UserMessageKind に直接適用
    pub enum UserMessageKind {
        Database,
        Validation,
        Io,
        NotFound,
        // ... 他のカテゴリ
        Unexpected,
    }

    #[derive(Debug, Error)]
    pub enum AppError {
        #[error("Database Error: {details}")]
        Database {
            user_message: String,
            details: String,
            source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
        },

        #[error("Validation Error on field '{field}': {message}")]
        Validation {
            user_message: String,
            field: String,
            message: String, // 開発者向け詳細
        },

        #[error("I/O Error: {details}")]
        Io {
            user_message: String,
            details: String,
            #[from] // std::io::Error からの自動変換の例
            source: std::io::Error,
        },

        #[error("Resource Not Found: Type='{resource_type}', ID='{resource_id}'. Details: {details}")]
        NotFound {
            user_message: String,
            resource_type: String,
            resource_id: String,
            details: String,
        },
        
        // anyhow::Error から変換する場合のバリアント例
        // #[error("Internal Server Error: {details}")]
        // InternalError {
        //     user_message: String, // 固定的なユーザーメッセージ
        //     details: String,      // anyhow::Error.to_string() の内容
        // }

        #[error("Unexpected Error: {details}")]
        Unexpected {
            user_message: String,
            details: String,
            source: Option<Box<dyn std::error::Error + Send + Sync + 'static>>,
        },
        // ... 他のエラーバリアント
    }

    // AppError は Serialize を手動実装し、SerializableAppError を経由して情報を制御
    // (SerializableAppError の定義と Serialize の実装は error.rs を参照)
    ```
  * 各種外部クレートのエラー型 (例: `sea_orm::DbErr`, `uuid::Error`, `serde_json::Error`) から `AppError` への変換は `From` トレイトを実装することで行い、その際に適切な `user_message` と `details` を設定します。

* **データベース操作**:  
  * sea-ormを全面的に採用します。  
  * **マイグレーション**: アプリケーション起動時に、sea-orm-migrationを用いて未適用のマイグレーションを自動で実行する処理を組み込みます。最初のマイグレーションファイルには、セクション6.1および6.2で定義されたテーブルと制約を作成するSQLを記述します。  
* **主要なCrateの役割**:  
  * `thiserror`: 独自エラー型 (`AppError` など) の定義に使用。
  * `anyhow`: アプリケーション内部での柔軟なエラーハンドリング、特に複数のエラー型を統一的に扱う場合やエラーコンテキストの追加に使用。
  * `uuid`: uuidカラムのグローバル一意ID生成に使用。  
  * `chrono`: タイムスタンプの生成に使用。

### **11.2. フロントエンド (SvelteKit) 方針**

* **状態管理 (State Management)**:  
  * Svelteの\*\*ストア（Stores）\*\*を活用し、リアクティブな状態管理を実現します。  
* **コンポーネント設計**:  
  * UIを機能単位で再利用可能なコンポーネントに分割します。  
* **バックエンドとの通信**:  
  * Tauri APIのinvoke関数をラップした関数群を専用モジュールに集約します。  
  * invokeはtry...catchブロックで囲み、バックエンドから返されるAppErrorを捕捉して適切に処理します。

### **11.3. プロジェクト構造**

* Tauriが生成する標準的なディレクトリ構造に準拠し、バックエンド (src-tauri/) とフロントエンド (src/) のコードを明確に分離します。

### **11.4. バージョニングと自動更新方針**

* **バージョニング体系**:  
  * セマンティックバージョニング (vMAJOR.MINOR.PATCH) を採用します。  
* **ビルドとリリース自動化**:  
  * GitHub Actions を利用して、ビルドとリリースのプロセスを自動化します。  
  * Gitタグがプッシュされた際にワークフローを実行し、成果物を自動でGitHub Releasesにアップロードします。  
* **アプリ内更新チェックと自動更新**:  
  * Tauri公式のUpdaterプラグイン (@tauri-apps/plugin-updater) を採用します。  
  * アプリケーション起動時に自動で更新をチェックし、ユーザーに通知・確認の上でアップデートを実行します。